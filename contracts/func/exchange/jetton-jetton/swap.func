{-
Требуемые данные:
ton_amount, jetton_amount, to_address, payload, query_id, fwd_fee, choise

Логика работы:
На основе side определяем:
  - кошелёк получения
  - кошелёк отправки
  - резервы получения
  - резервы отправки

Также после обмена ещё раз на основе side
определяем в какой резерв прибавлять и убавлять средства.
-}

() swap_jettons(int ton_amount, int jetton_amount, slice to_address, slice payload, int query_id, int fwd_fee, int sd) impure {
  int amount_out_min = payload~load_coins();

  ton_amount -= (fee::swap_jettons() + fwd_fee + fee::send_jetton());

  if (sd) { {- left->right -}
    slice jetton0_wallet = left_wallet;
    slice jetton1_wallet = right_wallet;
    int reserve0 = left_reserve;
    int reserve1 = right_reserve;
  } else { {- right->left -}
    slice jetton0_wallet = right_wallet;
    slice jetton1_wallet = left_wallet;
    int reserve0 = right_reserve;
    int reserve1 = left_reserve;
  }

  if (amount_out_min > reserve1) {
    send_jettons_payload(jetton0_wallet, to_address, ton_amount, jetton_amount, error::insufficient_liquidity(), query_id);
    commit();
    throw(error::insufficient_liquidity());
  }

  int amount_out = get_out_amount(jetton_amount, reserve1, reserve0);

  if (amount_out < amount_out_min) {
    send_jettons_payload(jetton0_wallet, to_address, ton_amount, jetton_amount, error::insufficient_slippage(), query_id);
    commit();
    throw(error::insufficient_slippage());
  }

  accumulate_price();

  if (sd) { {- left->right -}
    left_reserve += jetton_amount;
    right_reserve -= amount_out;
  } else { {- right->left -}
    right_reserve += jetton_amount;
    left_reserve -= amount_out;
  }

  send_jettons_payload(jetton1_wallet, to_address, 10000000, jetton_amount_out, op::successful_swap(), query_id); ;; 0.01 TON in payload
  save_data();
}
