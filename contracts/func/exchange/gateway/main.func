{-
Gateway for adding two jetton to liquidity

storage#_ exchange_address:MsgAddress user_address:MsgAddress
          jetton0_reserve:(VarUInteger 16)
          jetton1_reserve:(VarUInteger 16) = Storage;
-}
int min_tons_for_storage() asm "10000000 PUSHINT"; ;; 0.01 TON

(slice {-exchange-}, slice {-user-}, int {-reserve0-}, int {-reserve1-}) load_data() inline {
  slice ds = get_data().begin_parse();
  return (ds~load_msg_addr(), ds~load_msg_addr(), ds~load_coins(), ds~load_coins());
}


() save_data (slice exchange, slice user, int query_id, int reserve0, int reserve1) impure inline {
  set_data(begin_cell()
    .store_slice(exchange)
    .store_slice(user)
    .store_coins(reserve0)
    .store_coins(reserve1)
    .end_cell());
}


() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore empty messages
    return ();
  }
  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);

  if (flags & 1) { ;; ignore all bounced messages
    return ();
  }

  slice sender_address = cs~load_msg_addr();

  int op = in_msg_body~load_uint(32);
  int query_id = in_msg_body~load_uint(64);

  var (exchange_address, user_address, reserve0, reserve1) = load_data();

  if (op == op::gateway_incoming()) {
    throw_unless(error::invalid_address(), equal_slices(sender_address, exchange_address));
    int sd = in_msg_body~load_uint(1);
    int amount = in_msg_body~load_coins();

    if (sd) {
      reserve0 += amount;
    } else {
      reserve1 += amount;
    }

    if ((reserve0 > 0) & (reserve1 > 0 )) {
      builder message = begin_cell()
        .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
        .store_slice(exchange_address)
        .store_uint(1, 111) ;; 0 Gram + 106 zero bits + 1 one bit
        .store_ref(begin_cell()
          .store_uint(op::add_liquidity(), 32)
          .store_uint(query_id, 64)
          .store_slice(user_address)
          .store_coins(reserve0)
          .store_coins(reserve1)
          .end_cell()); ;; 987 bit
      raw_reserve(min_tons_for_storage(), 2);
      send_raw_message(message.end_cell(), 130);
      reserve0 = 0;
      reserve1 = 0;
    }

    save_data(exchange_address, user_address, reserve0, reserve1);
    return ();
  }

  if (op == op::withdraw()) {
    ;; TODO тут просто возврат двух токенов (возможно нужно сделать комсу)
  }
  throw(0xffff);
}
