() swap_to_jetton(int ton_amount, slice to_address, slice payload, int query_id, int fwd_fee) impure {
  int jettons_min = payload~load_coins();

  ton_amount -= (fee::swap_to_jetton() + fwd_fee + fee::send_jetton());

  throw_if(error::insufficient_ton(), ton_amount <= 0);
  throw_if(error::pool_is_not_init(), equal_slices(jetton_wallet, const::addr_none()));

  if (jettons_min > right_reserve) { ;; replace throw_if with bounce with save transaction chain
    send_tons_payload(to_address, ton_amount + fee::send_jetton(), error::insufficient_liquidity(), query_id);
    return ();
  }

  int jetton_amount_out = get_out_amount(ton_amount, left_reserve, right_reserve);

  if (jetton_amount_out < jettons_min) {
    send_tons_payload(to_address, ton_amount + fee::send_jetton(), error::insufficient_slippage(), query_id);
    return ();
  }

  accumulate_price();
  right_reserve -= jetton_amount_out;

  send_jettons_payload(jetton_wallet, to_address, 10000000, jetton_amount_out, op::successful_swap(), query_id); ;; 0.01 TON in payload
  save_data();
}


() swap_to_ton(int ton_amount, int jetton_amount, slice to_address, slice payload, int query_id, int fwd_fee) impure {
  int ton_min = payload~load_coins();

  ton_amount -= (fee::swap_to_ton() + fwd_fee + fee::send_jetton());

  if (ton_min > left_reserve) {
    send_jettons_payload(jetton_wallet, to_address, ton_amount, jetton_amount, error::insufficient_liquidity(), query_id);
    return ();
  }

  int ton_amount_out = get_out_amount(jetton_amount, right_reserve, left_reserve);

  if (ton_amount_out < ton_min) {
    send_jettons_payload(jetton_wallet, to_address, ton_amount, jetton_amount, error::insufficient_slippage(), query_id);
    return ();
  }

  accumulate_price();
  right_reserve += jetton_amount;

  send_tons_payload(to_address, ton_amount_out + fee::send_jetton(), p::successful_swap(), query_id);
  save_data();
}
