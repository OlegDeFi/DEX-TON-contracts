() add_liquidity(int ton_amount, int jetton_amount, slice user_address, slice payload, int query_id, int fwd_fee) impure {
  ;; TODO calculate fwd_fee for mint lp!
  ton_amount -= (fee::mint_lp() + fwd_fee * 13 + fee::send_jetton() + fee::send_lp() * 2); ;; ~0.13 TON
  ;; TODO remove throw_if (in jetton<->jetton version)
  throw_if(error::insufficient_ton(), ton_amount <= 0);

  int min_ton_amount = payload~load_coins();
  int min_jetton_amount = payload~load_coins();

  int change_ton_amount = 0;
  int change_jetton_amount = 0;
  int liquidity = 0;

  if (lp_supply == 0) { ;; or (right_reserve == 0) & (left_reserve == 0)
    lp_supply = cfg::minimum_liquidity();
    liquidity = sqrt(ton_amount * jetton_amount) - lp_supply;
  } else {
    int optimal_jetton_amount = quote(ton_amount, left_reserve, right_reserve);

    if (optimal_jetton_amount <= jetton_amount) {
      if (optimal_jetton_amount < min_jetton_amount) {
        send_jettons_payload(user_address, ton_amount, jetton_amount, error::insufficient_jetton_amount(), query_id);
        commit();
        throw(error::insufficient_jetton_amount());
      }

      change_jetton_amount = jetton_amount - optimal_jetton_amount;
      jetton_amount = optimal_jetton_amount;
    } else {
      int optimal_ton_amount = quote(jetton_amount, right_reserve, left_reserve);

      if ((optimal_ton_amount < min_ton_amount) | (optimal_ton_amount > ton_amount)) {
        send_jettons_payload(user_address, ton_amount, jetton_amount, error::insufficient_ton_amount(), query_id);
        commit();
        throw(error::insufficient_ton_amount());
      }

      change_ton_amount = ton_amount - optimal_ton_amount;
      ton_amount = optimal_ton_amount;
    }

    liquidity = min(
      (ton_amount * lp_supply) / left_reserve,
      (jetton_amount * lp_supply) / right_reserve
    );
  }

  ;; TODO: Is this throw_if necessary? -> Replace with bounce
  ;; throw_if(error::insufficient_liquidity_mint(), liquidity <= 0);

  if ((change_ton_amount > 0) | (change_jetton_amount > 0)) {
    send_jettons_payload(user_address, change_ton_amount, change_jetton_amount, op::return_change(), query_id); ;; return change
  }

  accumulate_price();
  kLast = left_reserve * right_reserve;
  left_reserve += ton_amount;
  right_reserve += jetton_amount;
  mint_fee();
  mint_lp(liquidity, user_address);
  save_data();
}


() remove_liquidity(slice sender_address, int ton_amount, int query_id, slice in_msg_body, int fwd_fee) impure {
  int lp_amount = in_msg_body~load_coins();
  slice from_address = in_msg_body~load_msg_addr();
  throw_unless(error::invalid_address(),
    equal_slices(calculate_user_jetton_wallet_address(from_address, my_address(), lp_wallet_code), sender_address));

  throw_if(error::insufficient_lp_amount(), lp_amount <= 0);

  int ton_share = (left_reserve * lp_amount) / lp_supply;
  int jetton_share = (right_reserve * lp_amount) / lp_supply;

  accumulate_price();
  kLast = left_reserve * right_reserve;
  left_reserve -= ton_share;
  right_reserve -= jetton_share;
  mint_fee();
  lp_supply -= lp_amount;

  builder body = begin_cell().store_uint(0, 1).store_coins(ton_share);
  send_jettons(from_address, jetton_share, ton_share, body, 3);

  raw_reserve(ton_amount - fee::send_jetton() - fee::remove_lp() - fwd_fee, 3);

  slice response_address = in_msg_body~load_msg_addr();
  builder msg_body = begin_cell()
    .store_uint(op::excesses(), 32)
    .store_uint(query_id, 64);
  send_tons(response_address, 0, msg_body, 2 + 64);
  save_data();
}
