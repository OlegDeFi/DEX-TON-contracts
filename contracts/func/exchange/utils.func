;; body schema:
;; <b 0 1 u, AMOUNT Grams, 1 1 u, BODY s,
() send_jettons(slice user_address, int jetton_amount, int ton_amount, builder body, int mode) impure inline {
  builder msg_body = begin_cell()
    .store_uint(op::transfer(), 32)
    .store_uint(cur_lt(), 64)
    .store_coins(jetton_amount)
    .store_slice(user_address)
    .store_slice(user_address);
  ifnot (null?(body)) {
    msg_body = msg_body.store_builder(body);
  } else {
    msg_body = msg_body.store_uint(0, 1 + 4 + 1); ;; empty dict, 0 coins, 0 either_forward_payload
  }

  builder msg = begin_cell()
    .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
    .store_slice(jetton_wallet)
    .store_coins(ton_amount + fee::send_jetton()) ;; ton_amount + ~0.05 TON
    .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_ref(msg_body.end_cell());

  send_raw_message(msg.end_cell(), mode);
}


() send_tons(slice to_address, int ton_amount, builder body, int mode) impure inline {
  var message = begin_cell()
    .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
    .store_slice(to_address)
    .store_coins(ton_amount)
    .store_uint(0, 107);
  ifnot (null?(body)) {
    message = message.store_builder(body);
  } else {
    message = message.store_uint(0, 32);
  }
  send_raw_message(message.end_cell(), null?(mode) ? 3 : mode); ;; ignore errors
}

;; bounce in error or other cases
() send_jettons_payload(slice address, int ton_amount, int jetton_amount, int op, int query_id) impure inline {
  builder msg_body = begin_cell()
    .store_uint(0, 1)
    .store_coins(ton_amount)
    .store_uint(0, 1)
    .store_uint(op, 32)
    .store_uint(query_id, 64);
  send_jettons(address, jetton_amount, ton_amount, msg_body, 3);
}


() send_tons_payload(slice address, int amount, int op, int query_id) impure inline {
  builder msg_body = begin_cell()
    .store_uint(op, 32)
    .store_uint(query_id, 64);
  send_tons(to_address, amount, msg_body, 3);
}


() accumulate_price() inline {
  int time_elapsed = now() - block_timestamp_last;
  if ((time_elapsed > 0) & (ton_reserve != 0) & (jetton_reserve != 0)) {
    ;; mb replace 1000000000 with 2**32 in the future
    price0_cumulative_last += (left_reserve * 1000000000 / right_reserve * time_elapsed);
    price1_cumulative_last += (right_reserve * 1000000000 / left_reserve * time_elapsed);
  }
  block_timestamp_last = now();
}


cell calculate_contract_state_init(cell contract_code, cell contract_data) inline {
  return begin_cell()
    .store_uint(0, 2)
    .store_dict(contract_code)
    .store_dict(contract_data)
    .store_uint(0, 1)
  .end_cell();
}


slice calculate_contract_address(cell state_init) inline {
  return begin_cell().store_uint(4, 3)
    .store_int(cfg::workchain(), 8)
    .store_uint(cell_hash(state_init), 256)
    .end_cell()
  .begin_parse();
}


(int) get_workchain(slice address) inline {
  (int wc, _) = parse_var_addr(address);
  return wc;
}


() force_chain(int workchain, slice address, int error_code) impure inline {
  (int wc) = get_workchain(address);
  throw_unless(error_code, wc == workchain);
  preload_bits();
}
