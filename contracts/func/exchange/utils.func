;; body schema:
;; <b 0 1 u, AMOUNT Grams, 1 1 u, BODY s,
() send_jettons(slice from_jetton_wallet, slice user_address, int jetton_amount, int ton_amount, builder body, int mode) impure inline {
  builder msg_body = begin_cell()
    .store_uint(op::transfer(), 32)
    .store_uint(cur_lt(), 64)
    .store_coins(jetton_amount)
    .store_slice(user_address)
    .store_slice(user_address);
  ifnot (null?(body)) {
    msg_body = msg_body.store_builder(body);
  } else {
    msg_body = msg_body.store_uint(0, 1 + 4 + 1); ;; empty dict, 0 coins, 0 either_forward_payload
  }

  builder msg = begin_cell()
    .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
    .store_slice(from_jetton_wallet)
    .store_coins(ton_amount + fee::send_jetton()) ;; ton_amount + ~0.05 TON
    .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_ref(msg_body.end_cell());

  send_raw_message(msg.end_cell(), mode);
}


() send_tons(slice to_address, int ton_amount, builder body, int mode) impure inline {
  var message = begin_cell()
    .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
    .store_slice(to_address)
    .store_coins(ton_amount)
    .store_uint(0, 107);
  ifnot (null?(body)) {
    message = message.store_builder(body);
  } else {
    message = message.store_uint(0, 32);
  }
  send_raw_message(message.end_cell(), null?(mode) ? 3 : mode); ;; ignore errors
}

;; bounce in error or other cases
() send_jettons_payload(slice from_jetton_wallet, slice address, int ton_amount, int jetton_amount, int op, int query_id) impure inline {
  builder msg_body = begin_cell()
    .store_uint(0, 1)
    .store_coins(ton_amount)
    .store_uint(0, 1)
    .store_uint(op, 32)
    .store_uint(query_id, 64);
  send_jettons(from_jetton_wallet, address, jetton_amount, ton_amount, msg_body, 3);
}


() send_tons_payload(slice address, int amount, int op, int query_id) impure inline {
  builder msg_body = begin_cell()
    .store_uint(op, 32)
    .store_uint(query_id, 64);
  send_tons(address, amount, msg_body, 3);
}


() accumulate_price() inline {
  int time_elapsed = now() - block_timestamp_last;
  if ((time_elapsed > 0) & (left_reserve != 0) & (right_reserve != 0)) {
    ;; mb replace 1000000000 with 2**32 in the future
    price0_cumulative_last += (left_reserve * 1000000000 / right_reserve * time_elapsed);
    price1_cumulative_last += (right_reserve * 1000000000 / left_reserve * time_elapsed);
  }
  block_timestamp_last = now();
}
