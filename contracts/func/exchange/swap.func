
int get_out_amount(int in_amount, int in_reserve, int out_reserve) inline {
  ;; TODO mb remove these throw_if
  throw_if(error::insufficient_amount(), in_amount == 0);
  throw_if(error::insufficient_liquidity(), (in_reserve == 0) | (out_reserve == 0));

  int in_amount_with_fee = in_amount * 997;
  int numerator = in_amount_with_fee * out_reserve;
  int denominator = (in_reserve * 1000) + in_amount_with_fee;
  int out_amount = numerator / denominator;
  return out_amount;
}

() swap_to_jetton(int ton_amount, slice sender_address, slice in_msg_body) impure {
  int jettons_min = in_msg_body~load_coins();

  ton_amount -= fee::swap_to_jetton();

  throw_if(error::insufficient_ton(), ton_amount <= 0);

  int jetton_amount_out = get_out_amount(ton_amount, ton_reserve, jetton_reserve);
  jetton_amount_out~dump();
  if (jetton_amount_out < jettons_min) {
    send_tons(sender_address, ton_amount + 75000000, begin_cell().store_int(error::insufficient_output_amount(), 32), 2);
    return ();
  }

  jetton_reserve -= jetton_amount_out;

  send_jettons(sender_address, jetton_amount_out, 40000000, null(), 3);
  save_data();
}


() swap_to_ton(int ton_amount, int jetton_amount, slice to_address, slice in_msg_body) impure {
  int ton_min = in_msg_body~load_coins();

  ton_amount -= fee::swap_to_ton();
  throw_if(error::insufficient_ton(), ton_amount <= 0);

  int ton_amount_out = get_out_amount(jetton_amount, jetton_reserve, ton_reserve);
  ton_amount_out~dump();
  if (ton_amount_out < ton_min) {
    return_jettons(to_address, ton_amount, jetton_amount);
    commit();
    throw(error::insufficient_output_amount());
  }

  jetton_reserve += jetton_amount;

  send_tons(to_address, ton_amount_out, null(), 3);
  save_data();
}